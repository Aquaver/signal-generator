# Signal Generator

Signal Generator is a project of a GUI application based on Qt framework, which allows generating signal models that are representations of periodic waveforms (for instance electrical ones) in four main ways - as sinusoidal, square, triangular and sawtooth waveform. This program uses a simple class hierarchy consisting of an abstract base class which defines mathematical model of a signal, and three subclasses implementing sine, square and triangular (including sawtooth) waveforms. In addition, a class which comes from part of project that was generated by Qt, used to handle graphical user interface, realizes `use` relation between itself and these classes when generating waveforms, to transform the mathematical model into graphical representation of the signal.

## Class structure implementation

Application's main logic part consists of header files with field and method definitions, and specific for this language - separate source files with implementation of that class methods (including mathematical model functions) for generated waveforms.

```cpp
#pragma once

#include <QtGlobal>
#include <QVector>

class Signal {
  public:
    bool isSelected = false;

    QVector<qreal> getArguments();
    QVector<qreal> getValues();

    void setArguments(QVector<qreal> newArguments);
    qint32 signalLength(); // Returns length of arguments/values set (they should be equal - if not then this function returns -1 which means an error).

  protected:
    static qreal shiftX, shiftY;

    QVector<qreal> arguments;
    QVector<qreal> values;

    virtual qreal signalFunction(qreal argument) = 0; // Master signal function (mathematical model) which converts an argument into proper value.
    virtual void calculateValues(); // Computes values vector from arguments vector.

  private:
    bool valuesValid = false;
    friend class CompoundSignal;
};
```

The first class, which is the base abstract one for all types of waveforms is named `Signal` and its body is implemented in its own file. It consists of fields that define behavior of each possible generated signal and simple operations that can be performed on them, such as setting a set of arguments, computing values and retrieving that set of calculated values for this waveform. In addition, a `friend` relationship with another class `CompoundSignal` is also defined here, to allow access to private fields of this class and implement creating compound waveforms.

Second class, but first derived from `Signal` one is named `Sine` which indicates that it defines the mathematical model of sinusoidal waveform. As it inherits from a common base class, it is not needed to redefine all the methods and fields. However, in order to be able to create instances of this class, it must overload and implement `signalFunction()` method in which the actual model of the waveform will be stored. This function allows computing set of arguments into set of values. Besides, this class contains some necessary parameters of sine wave - amplitude, frequency, phase shift (horizontal shift) and constant component (vertical shift). Example of generated sinusoidal waveform is shown on the picture below.

<p align="center">
  <img alt="Sine waveform example" src="https://raw.githubusercontent.com/Aquaver/signal-generator/master/assets/example-sine.png">
</p>

The header code file of the next class does not differ from the code of the previous one. Class `Square` defines parameters of the square (rectangular) waveform. It implements its own way of computing function value by overriding `signalFunction()` method and allows creating a new instance of the waveform through the constructor. However, there is one parameter that is limited to strict range. This parameter is defined as `dutyCycle` and its value must be in range from 0 up to 100 (inclusive), so when creating new object, there must be some validation mechanism for checking this condition. For this purpose, an additional implementation file was created, in which the constructor body was included.

```cpp
Square::Square(qreal amplitude, qreal constant, qreal dutyCycle, qreal period, qreal phase) : amplitude{amplitude}, constant{constant}, dutyCycle{dutyCycle}, period{period}, phase{phase} {
  if (dutyCycle < 0 || dutyCycle > 100) {
    perror("[Debug Error] Created Square waveform with invalid duty cycle");
    dutyCycle = 50;
  }
}
```

Very simple mechanism has been defined here, which provides validation for the `dutyCycle` parameter. It must be a proper real value in range from 0 to 100. Otherwise, an error message will be displayed and creating an instance of this class will not happen. Example of generated square waveform with 50 percent duty cycle is shown below. Note that the amplitude for square waveform is not equal to the peak to peak value, but from peak to the middle point. Hence this, the signal total height equals twice the amplitude.

<p align="center">
  <img alt="Square waveform example" src="https://raw.githubusercontent.com/Aquaver/signal-generator/master/assets/example-square.png">
</p>

The last class which directly inherits from `Signal` is class called `Triangular` that defines mathematical model of a signal with triangular waveform, but also it allows creating sawtooth waveform by adjusting its parameters. This class is the most complex from the three, but it gives possibility to create a lot of different signal waveforms. For example, to generate a perfect triangular signal, the length of the rising edge must be equal to length of the falling one, and dead time should be set to zero.

<p align="center">
  <img alt="Triangular waveform example" src="https://raw.githubusercontent.com/Aquaver/signal-generator/master/assets/example-triangular.png">
</p>

Unlike square and sinusoidal waveforms, the amplitude of triangular one equals to the total height of the waveform (peak to peak value), because in this type of signal, typical middle point cannot be determined due to its vertically asymmetric character. On the other hand, to generate a sawtooth waveform with similar parameters (amplitude and dead time) it is enough to set sufficiently large ratio of both edge lengths. For example, below waveform has left (rising) edge time set to 0.99 seconds while the time of right (falling) edge is equal to 0.01 seconds. This values pair results in total period of the signal equal to one second and perfectly closes the signal in length of single horizontal division which magnitude is shown in the upper left corner of the chart field.

<p align="center">
  <img alt="Sawtooth waveform example" src="https://raw.githubusercontent.com/Aquaver/signal-generator/master/assets/example-sawtooth.png">
</p>

## Compound signal waveforms

After the three basic types of waveforms, whose classes inherit directly from the `Signal` abstract base class, it is necessary to explain one more class which also inherits from `Signal` but additionally has privilege of accessing private fields of each instance, because of the `friend` relationship, defined with `CompoundSignal` class. Granted permissions to directly get and set the values of private fields are necessary for retrieving protected `signalFunction()` method from both instances. In newly created waveform object in its own `signalFunction()` method, functions with the same name from the both ones are used to compute final value of compound signal instance, depending on type of the operation - whether it is sum or difference.

```cpp
#pragma once

#include "src/headers/compound-type.h"
#include "src/headers/signal.h"

class CompoundSignal : public Signal {
  public:
    void setCompoundSignals(Signal* first, Signal* second);
    void setCompoundType(CompoundType newType);

  protected:
    virtual qreal signalFunction(qreal argument) override;

  private:
    CompoundType type = CompoundType::SUM; // Sum is the default signal compound type.
    Signal* firstSignal = nullptr;
    Signal* secondSignal = nullptr;
};
```

Class `CompoundSignal` besides defining in its fields two pointers to the `Signal` class that contains signals from which the new compound waveform will be created, it is also has its own type named `CompoundType` that determines the way of combining signals - add or subtract. Overridden `signalFunction()` method defines a very simple mechanism for performing operations on member signals that uses the same methods from them to compute final value based on values from first and second component. This allows to numerically determine a waveform composed of two signal waveforms with arbitrary shape. Below example of compound signal that consists of six sinusoidal waveforms with amplitude equal to 1 and following frequencies `3; 3.1; 3.2; 3.3; 3.4 and 3.5` that result it specific for this set, beat interference.

<p align="center">
  <img alt="Compound (beat) waveform example" src="https://raw.githubusercontent.com/Aquaver/signal-generator/master/assets/example-compound-beat.png">
</p>

Next example shows a complex waveform (orange color) that consists of a sinusoidal signal (with white color) and pure square one (also with white color) whose amplitude is relatively small compared with sine signal's amplitude but with much higher frequency. Determining of such function with analytical methods would be quite difficult, but doing it by numerical method (argument by argument), this task has been simplified as much as possible.

<p align="center">
  <img alt="Compound (sine and square) waveform example" src="https://raw.githubusercontent.com/Aquaver/signal-generator/master/assets/example-compound-sine-square.png">
</p>

Shown examples above illustrate that with numerical composition mechanism (somewhat connected with Fourier analysis), implemented three types of waveforms result in literally unlimited possibilities to create different types of waveforms with countless shapes.
